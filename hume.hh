/*
	search routine generated by gen.
	skip=no, match=rev, shift=d12
*/
/*
 * The authors of this software are Andrew Hume and Daniel Sunday.
 * 
 * Copyright (c) 1991 by AT&T and Daniel Sunday.
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * 
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 */

#include <boost/array.hpp>

#include <cstring>
#include <cstdlib>
#include <vector>
#include <algorithm>

#define	MAXPAT	256

#ifndef	TABTYPE
#define	TABTYPE	long
#endif
typedef TABTYPE Tab;

typedef boost::array<unsigned char, MAXPAT> array_type;

struct pattern
{
    int patlen;
    array_type pat;
    Tab delta1[256];
    Tab delta2[257];
    Tab delta[256];
    Tab dg[MAXPAT][128];
    int rarec, rareoff;
    int md2;

    long cmps, accs;
    
    pattern() : patlen(0) {}
};

static pattern pat = {0, std::vector<unsigned char>(MAXPAT)};

typedef typename array_type::const_iterator pat_iterator;

template <typename RandomAccessIterator>
void bmprep(RandomAccessIterator base, int m)
{
	Tab *d2;
	int q1, t, qp, jp, kp, j;
	Tab f[256], f1[256];

	pat.patlen = m;
	if(m > MAXPAT)
		abort();
        std::copy(base, base + m, pat.pat.begin());
	d2 = pat.delta1;
        std::fill(d2, d2 + 256, m);
	for(j = 0; j < m; j++)
		d2[base[j]] = m-1-j;
        
	d2 = pat.delta2;
	for(j = 1; j < m; j++)
		d2[j] = 2*m-j;
	for(j = m, t = m+1; j > 0; j--, t--){
		f[j] = t;
		while((t <= m) && (base[t-1] != base[j-1])){
			if((m-j) < d2[t])
				d2[t] = m-j;
			t = f[t];
		}
	}
	q1 = t;
	t = m+1-q1;
	qp = 1;
	for(jp = 1, kp = 0; kp < t; jp++, kp++){
		f1[jp] = kp;
		while((kp >= 1) && (base[jp-1] != base[kp-1]))
			kp = f1[kp];
	}
	while(q1 < m){
		for(j = qp; j <= q1; j++)
			if(m+q1-j < d2[j])
				d2[j] = m+q1-j;
		qp = q1+1;
		q1 += t-f1[t];
		t = f1[t];
	}

	d2[0] = m+1;		/* the case where the match succeeded */
}

template <typename RandomAccessIterator>
RandomAccessIterator bmexec_cnt(RandomAccessIterator base, int n)
{
        RandomAccessIterator e, s;
	int s_offset;
        RandomAccessIterator p, q;
	int n1 = pat.patlen-1;
        RandomAccessIterator ep;
	Tab *d1 = pat.delta1;
	Tab *d2 = pat.delta2+1;
	int k1, k2;

	s = base+pat.patlen-1;
	e = base+n;
	s_offset = 1-pat.patlen;
	ep = pat.pat; pat.cmps = pat.accs = 0;
	while(s < e){
		for(p = pat.pat.begin()+n1, q = s+n1+s_offset; p >= ep; ){
			if(++pat.cmps,(*q-- != *p--)){
				q++, p++;
				goto mismatch;
			}
		}
		if(p < ep) return q+1; else return q;
	mismatch:
		k2 = d2[p-pat.pat];
		k1 = d1[*q]; ++pat.accs;
		if(k2 < k1)
			k2 = k1;
		k2 = q+k2-s+n1+s_offset;
		s += k2;
	}
	return e;
}

template <typename RandomAccessIterator>
RandomAccessIterator bmexec(RandomAccessIterator base, int n)
{
        RandomAccessIterator e, s;
	int s_offset;
        RandomAccessIterator p, q;
	int n1 = pat.patlen-1;
        RandomAccessIterator ep;
	Tab *d1 = pat.delta1;
	Tab *d2 = pat.delta2+1;
	int k1, k2;

	s = base+pat.patlen-1;
	e = base+n;
	s_offset = 1-pat.patlen;
	ep = pat.pat;
	while(s < e){
		for(p = pat.pat.begin()+n1, q = s+n1+s_offset; p >= ep; ){
			if(*q-- != *p--){
				q++, p++;
				goto mismatch;
			}
		}
		if(p < ep) return q+1; else return q;
	mismatch:
		k2 = d2[p-pat.pat];
		k1 = d1[*q];
		if(k2 < k1)
			k2 = k1;
		k2 = q+k2-s+n1+s_offset;
		s += k2;
	}
	return(e);
}

template <typename RandomAccessIterator1, typename RandomAccessIterator2>
RandomAccessIterator1 slowbm(RandomAccessIterator1 text, RandomAccessIterator1 textEnd, RandomAccessIterator2 pat, RandomAccessIterator2 patEnd) 
{
  bmprep(pat, patEnd - pat);  
  return bmexec(text, textEnd - text);
}

/*
template <class RandomAccessIterator1, class RandomAccessIterator2>
RandomAccessIterator1 slowbm(
                    RandomAccessIterator1 txt, RandomAccessIterator1 txtEnd,
                    RandomAccessIterator2 pt, RandomAccessIterator2 ptEnd)
{
#ifdef __GNUC__
  CHARTYPE* pat = (CHARTYPE*)pt;
  CHARTYPE* text = (CHARTYPE*)txt;
#else
  CHARTYPE* pat = (CHARTYPE*)pt.base();
  CHARTYPE* text = (CHARTYPE*)txt.base();
#endif
  bmprep(pat, ptEnd - pt);
  CHARTYPE* result = bmexec_cnt(text, txtEnd - txt);
  data::accesses = ::pat.accs;
  data::equal_comparisons = ::pat.cmps;
#ifdef __GNUC__
  return (RandomAccessIterator1)result;
#else
  return (RandomAccessIterator1)(data*)result;
#endif
}
*/

#include "freq.h"

template <typename RandomAccessIterator>
void humprep(RandomAccessIterator base, int m)
{
        pat_iterator skipc;
        pat_iterator pe, p;
	int j;
	Tab *d;
	int rrr, rr;
        pat_iterator pmd2;

	pat.patlen = m;
	if(m > MAXPAT)
		abort();
        std::copy(base, base + m, pat.pat.begin());
	d = pat.delta;
	for(j = 0; j < 256; j++)
		d[j] = pat.patlen;
	for(p = pat.pat.begin(), pe = p+m-1; p < pe; p++)
		d[*p] = pe-p;
	d[*p] = 0;
	skipc = p;
	rrr = 0;
	for(rr = 1; rr < m; rr++){
		if(freq[pat.pat[rr]] < freq[pat.pat[rrr]])
			rrr = rr;
	}
	pat.rarec = pat.pat[rrr];
       	pat.rareoff = rrr - (m-1);
	for(pmd2 = skipc-1; pmd2 >= pat.pat.begin(); pmd2--)
		if (*pmd2 == *skipc) break;
	pat.md2 = skipc - pmd2;	/* *pmd2 is first leftward reoccurance of *pe */
}

template <typename RandomAccessIterator>
RandomAccessIterator humexec(RandomAccessIterator base, int n)
{
        RandomAccessIterator e, s, q;
	Tab *d0 = pat.delta;
        pat_iterator p;
        pat_iterator ep;
	int ro, rc;
	int n1 = pat.patlen-1;
	int md2 = pat.md2;

	s = base+pat.patlen-1;
	e = base+n;
	ro = pat.rareoff;
	rc = pat.rarec;

        ep = pat.pat.begin() + pat.patlen-1;
	while(s < e){
	        int k = 0;
                while( (k = d0[static_cast<char unsigned>(*(s += k))]) != 0 && (s < e));
		if(s >= e)
			break;
		if(s[ro] != rc)
			goto mismatch;

		for(p = pat.pat.begin(), q = s-n1; p < ep; ){
			if(*q++ != *p++)
				goto mismatch;
		}
		return s - n1;
	mismatch:
		s += md2;
	}
	return e;
}

template <typename RandomAccessIterator>
RandomAccessIterator humexec_cnt(RandomAccessIterator base, int n)
{
        RandomAccessIterator e, s;
	Tab *d0 = pat.delta;
	int ro, rc;

	pat_iterator p, q;
	pat_iterator ep;
	int n1 = pat.patlen-1;
	int md2 = pat.md2;

	s = base+pat.patlen-1;
	e = base+n;

	ro = pat.rareoff;
	rc = pat.rarec;

	ep = pat.pat.begin() + pat.patlen-1; pat.cmps = pat.accs = 0;
	while(s < e){
	        int k = 0;
	        while( (++pat.accs,(k = d0[*(s += k)])) != 0 && (s < e));
		if(s >= e)
			break;
		if(++pat.cmps,(s[ro] != rc))
			goto mismatch;
		for(p = pat.pat.begin(), q = s-n1; p < ep; ){
			if(++pat.cmps,(*q++ != *p++))
				goto mismatch;
		}
		return s - n1;
	mismatch:
		s += md2;
	}
	return e;
}


template <typename RandomAccessIterator1, typename RandomAccessIterator2>
RandomAccessIterator1 hume(RandomAccessIterator1 text, RandomAccessIterator1 textEnd, RandomAccessIterator2 pat, RandomAccessIterator2 patEnd) 
{
  humprep(pat, patEnd - pat);  
  return humexec(text, textEnd - text);
}

/*

template <class RandomAccessIterator1, class RandomAccessIterator2>
RandomAccessIterator1 hume(
                    RandomAccessIterator1 txt, RandomAccessIterator1 txtEnd,
                    RandomAccessIterator2 pt, RandomAccessIterator2 ptEnd)
{
#ifdef __GNUC__
  CHARTYPE* pat = (CHARTYPE*)pt;
  CHARTYPE* text = (CHARTYPE*)txt;
#else
  CHARTYPE* pat = (CHARTYPE*)pt.base();
  CHARTYPE* text = (CHARTYPE*)txt.base();
#endif
  humprep(pat, ptEnd - pt);
  CHARTYPE* result = humexec_cnt(text, txtEnd - txt);
  data::accesses = ::pat.accs;
  data::equal_comparisons = ::pat.cmps;
#ifdef __GNUC__
  return (RandomAccessIterator1)result;
#else
  return (RandomAccessIterator1)(data*)result;
#endif
}

*/

template <typename RandomAccessIterator>
void fbmprep(RandomAccessIterator base, int m)
{
	pat_iterator pe, p;
	int j;
	Tab *d;
	Tab *d2;
	int q1, t, qp, jp, kp;
	Tab f[256], f1[256];

	pat.patlen = m;
	if(m > MAXPAT)
		abort();
        std::copy(base, base + m, pat.pat.begin());
	d = pat.delta;
	for(j = 0; j < 256; j++)
		d[j] = pat.patlen;
	for(p = pat.pat.begin(), pe = p+m-1; p < pe; p++)
		d[*p] = pe-p;
	d[*p] = 0;

	d2 = pat.delta1;
	for(j = 0; j < 256; j++)
		d2[j] = m;
	for(j = 0; j < m; j++)
            d2[static_cast<char unsigned>(base[j])] = m-1-j;
	d2 = pat.delta2;
	for(j = 1; j < m; j++)
		d2[j] = 2*m-j;
	for(j = m, t = m+1; j > 0; j--, t--){
		f[j] = t;
		while((t <= m) && (base[t-1] != base[j-1])){
			if((m-j) < d2[t])
				d2[t] = m-j;
			t = f[t];
		}
	}
	q1 = t;
	t = m+1-q1;
	qp = 1;
	for(jp = 1, kp = 0; kp < t; jp++, kp++){
		f1[jp] = kp;
		while((kp >= 1) && (base[jp-1] != base[kp-1]))
			kp = f1[kp];
	}
	while(q1 < m){
		for(j = qp; j <= q1; j++)
			if(m+q1-j < d2[j])
				d2[j] = m+q1-j;
		qp = q1+1;
		q1 += t-f1[t];
		t = f1[t];
	}
	d2[0] = m+1;		/* the case where the match succeeded */
}

template <typename RandomAccessIterator>
RandomAccessIterator fbmexec(RandomAccessIterator base, int n)
{
        RandomAccessIterator e, s, q;
	Tab *d0 = pat.delta;

        pat_iterator p;
        pat_iterator prev(pat.pat.begin() + pat.patlen - 1);
	Tab *d2 = pat.delta2+1;
	int k1;

	s = base+pat.patlen-1;
	e = base+n;

	while(s < e){
	        int k = 0;
                while( (k = d0[static_cast<char unsigned>(*(s += k))]) != 0 && (s < e));
		if(s >= e)
			break;
                for(p = prev, q = s; p > pat.pat.begin(); ){
			if(*--q != *--p)
				goto mismatch;
		}
		return q;
	mismatch:
                k = d2[p - pat.pat.begin()];
                k1 = d0[static_cast<char unsigned>(*q)];
		if(k < k1)
			k = k1;
                s = RandomAccessIterator(q+k);
	}
	return e;
}

template <typename RandomAccessIterator>
RandomAccessIterator fbmexec_cnt(RandomAccessIterator base, int n)
{
        RandomAccessIterator e, s;
	Tab *d0 = pat.delta;

	pat_iterator p, q;
	pat_iterator prev = pat.pat.begin()+pat.patlen-1;
	Tab *d2 = pat.delta2+1;
	int k1;

	s = base+pat.patlen-1;
	e = base+n; pat.cmps = pat.accs = 0;
	while(s < e){
	        int k = 0;
	        while( (++pat.accs,(k = d0[*(s += k)])) != 0 && (s < e));
		if(s >= e)
			break;
		for(p = prev, q = s; p > pat.pat.begin(); ){
			if(++pat.cmps,(*--q != *--p))
				goto mismatch;
		}
		return q;
	mismatch:
		k = d2[p-pat.pat.begin()];
		k1 = d0[*q];++pat.accs;
		if(k < k1)
			k = k1;
		s = q+k;
	}
	return e;
}

template <typename RandomAccessIterator1, typename RandomAccessIterator2>
RandomAccessIterator1 fbm(RandomAccessIterator1 text, RandomAccessIterator1 textEnd, RandomAccessIterator2 pat, RandomAccessIterator2 patEnd) 
{
  fbmprep(pat, patEnd - pat);  
  return fbmexec(text, textEnd - text);
}

/*
template <class RandomAccessIterator1, class RandomAccessIterator2>
RandomAccessIterator1 fbm(
                    RandomAccessIterator1 txt, RandomAccessIterator1 txtEnd,
                    RandomAccessIterator2 pt, RandomAccessIterator2 ptEnd)
{
#ifdef __GNUC__
  CHARTYPE* pat = (CHARTYPE*)pt;
  CHARTYPE* text = (CHARTYPE*)txt;
#else
  const CHARTYPE* pat = (const CHARTYPE*)pt.base();
  const CHARTYPE* text = (const CHARTYPE*)txt.base();
#endif
  fbmprep(pat, ptEnd - pt);
  CHARTYPE* result = fbmexec_cnt(text, txtEnd - txt);
  data::accesses = ::pat.accs;
  data::equal_comparisons = ::pat.cmps;
#ifdef __GNUC__
  return (RandomAccessIterator1)result;
#else
  return (RandomAccessIterator1)(data*)result;
#endif
}
*/
template <typename RandomAccessIterator>
void gdprep(RandomAccessIterator base, int m)
{
        pat_iterator pe, p;
	int j;
	Tab *d;
	int j0, k, q, i, jj;
	int endof[MAXPAT], rmin[MAXPAT];

	pat.patlen = m;
	if(m > MAXPAT)
		abort();
        std::copy(base, base + m, pat.pat.begin());
	d = pat.delta;
	for(j = 0; j < 256; j++)
		d[j] = pat.patlen;
	for(p = pat.pat.begin(), pe = p+m-1; p < pe; p++)
		d[*p] = pe-p;
	d[*p] = 0;
	/*
		endof[k] is the maximal integer such that k is not a period
		rmin[jj] is the minimal period of p[0,m-1] > jj
		rmin[0] is the period of pat
	*/

	for(i=0; i<m; i++)
		rmin[i] = m;
	for(k = 1, i = k, jj = 0; k < m; ){
		while((pat.pat[i] == pat.pat[i-k]) && (i < m))
			i++;
		endof[k] = i;
		q = k+1;
		if(i == m){
			for(j0 = jj; j0 < k; j0++)
				rmin[j0] = k;  
			jj = k;
		}
		while(endof[q-k]+k < i){ 
       			endof[q] = endof[q-k]+k;
       			q = q+1;
		}
		k = q;
		if(k == i+1)
			i = k;
	}

	/* compute pat.dg[jj,a] */
	for(jj = 0; jj < m; jj++){ 
		for(i = 0; i < 128; i++)
			pat.dg[jj][i] = m-1-jj+rmin[jj];
	}
	for(k = m-2; k >= 0; k--){
		for(i = k, jj = m-1; pat.pat[i] == pat.pat[jj]; i--, jj--)
			;
		if((i >= 0) && (pat.dg[jj][pat.pat[i]]>=m))
			pat.dg[jj][pat.pat[i]] = m-1-i;
	}
}

template <typename RandomAccessIterator>
RandomAccessIterator gdexec(RandomAccessIterator base, int n)
{
        RandomAccessIterator e, s, q;
	Tab *d0 = pat.delta;

        pat_iterator p;
        pat_iterator prev = pat.pat.begin()+pat.patlen-1;
	int kg;

	s = base+pat.patlen-1;
	e = base+n;
	while(s < e){
	        int k = 0;
                while( (k = d0[static_cast<char unsigned>(*(s += k))]) != 0 && (s < e));
		if(s >= e)
			break;
		for(p = prev, q = s; p > pat.pat.begin(); ){
			if(*--q != *--p)
				goto mismatch;
		}
		return q;
	mismatch:
		if(p < pat.pat.begin())
			kg = pat.patlen+1;
		else
                        kg = pat.dg[p-pat.pat.begin()][static_cast<char unsigned>(*q)];
		s = q+kg;
	}
	return e;
}

template <typename RandomAccessIterator>
RandomAccessIterator gdexec_cnt(RandomAccessIterator base, int n)
{
        RandomAccessIterator e, s;
        Tab *d0 = pat.delta;

        RandomAccessIterator p, q;
        RandomAccessIterator prev = pat.pat.begin()+pat.patlen-1;
	int kg;

	s = base+pat.patlen-1;
	e = base+n; pat.accs = pat.cmps = 0;
	while(s < e){
	        int k = 0;
	        while( (++pat.accs,(k = d0[*(s += k)])) != 0 && (s < e));
		if(s >= e)
			break;
		for(p = prev, q = s; p > pat.pat.begin(); ){
			if(++pat.cmps,(*--q != *--p))
				goto mismatch;
		}
		return q;
	mismatch:
		if(p < pat.pat.begin())
			kg = pat.patlen+1;
		else
		  {kg = pat.dg[p-pat.pat.begin()][*q]; ++pat.accs;}
		s = q+kg;
	}
	return e;
}

template <typename RandomAccessIterator1, typename RandomAccessIterator2>
RandomAccessIterator1 gdbm(RandomAccessIterator1 text, RandomAccessIterator1 textEnd, RandomAccessIterator2 pat, RandomAccessIterator2 patEnd) 
{
  gdprep(pat, patEnd - pat);  
  return gdexec(text, textEnd - text);
}

/*

template <class RandomAccessIterator1, class RandomAccessIterator2>
RandomAccessIterator1 gdbm(
                    RandomAccessIterator1 txt, RandomAccessIterator1 txtEnd,
                    RandomAccessIterator2 pt, RandomAccessIterator2 ptEnd)
{
#ifdef __GNUC__
  CHARTYPE* pat = (CHARTYPE*)pt;
  CHARTYPE* text = (CHARTYPE*)txt;
#else
  CHARTYPE* pat = (CHARTYPE*)pt.base();
  CHARTYPE* text = (CHARTYPE*)txt.base();
#endif
  gdprep(pat, ptEnd - pt);
  CHARTYPE* result = gdexec_cnt(text, txtEnd - txt);
  data::accesses = ::pat.accs;
  data::equal_comparisons = ::pat.cmps;
#ifdef __GNUC__
  return (RandomAccessIterator1)result;
#else
  return (RandomAccessIterator1)(data*)result;
#endif
}

*/
